% meow/1

declare type-app;
declare term;
declare ref;

union loc {
  unknown;
  range(source: text, start: i32, stop: i32);
}

struct grammar(
  name: text,
  top: type-app,
  rules: array<rule>,
  types: array<type-decl>
);

union type-decl {
  record(loc: loc, name: text, formals: array<text>, fields: array<field>);
  'union(loc: loc, name: text, formals: array<text>, variants: array<variant>);
}

struct variant(loc: loc, name: text, fields: array<field>);
struct field(loc: loc, name: text, type: type-app);

struct rule-signature(
  name: text,
  formals: array<text>,
);

union rule {
  define(loc: loc, sig: rule-signature, desc: maybe<text>, body: array<rule-body>);
  override(loc: loc, sig: rule-signature, body: array<rule-body>);
  extend(loc: loc, sig: rule-signature, body: array<rule-body>);
  token(loc: loc, rule: rule);
}

struct rule-body(
  loc: loc,
  terms: array<binder>,
  expr: maybe<expr>,
);

union binder {
  bound(loc: loc, name: text, term: term);
  unbound(loc: loc, term: term);
}

union term {
  seq(loc: loc, terms: array<term>);
  alt(loc: loc, terms: array<term>);
  star(loc: loc, term: term);
  plus(loc: loc, term: term);
  opt(loc: loc, term: term);
  'not(loc: loc, term: term);
  lookahead(loc: loc, term: term);
  lex(loc: loc, term: term);
  apply(loc: loc, name: ref, args: array<term>);
  range(loc: loc, from: text, to: text);
  terminal(loc: loc, value: text);
  parens(loc: loc, term: term);
}

union type-app {
  ref(loc: loc, name: ref);
  apply(loc: loc, callee: type-app, args: array<type-app>);
  project(loc: loc, type: type-app, field: text);
  list(loc: loc, type: type-app);
  maybe(loc: loc, type: type-app);
}

union ref {
  relative(loc: loc, names: array<text>);
}

union expr {
  meta(loc: loc);
  make(loc: loc, ctor: expr, args: array<expr>);
  project(loc: loc, obj: expr, field: text);
  var(loc: loc, name: text);
  list(loc: loc, items: array<expr>);
  cons(loc: loc, head: array<expr>, tail: expr);
  apply(loc: loc, name: text, args: array<expr>);
  null(loc: loc);
}