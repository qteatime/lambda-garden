% meow/1

import foreign "native/parser.js";

open package meow.codec as c;


def #loc from(Range: array) {
  new loc..range(
    source: Range at!(0n),
    start: Range at!(2n),
    stop: Range at!(3n)
  );
}

def #loc source(Range: array) {
  Range at!(1n);
}

def lingua load-grammar(Source: text) -> result<grammar, load-error> {
  let Result0 = foreign parse(Source, "Grammar", [
    "TypeDecl_record": {R, _, Name, Formals, _, Fields, _ in new type-decl..record(#loc from(R), Name, Formals, Fields) },
    "TypeDecl_union": {R, _, Name, Formals, _, _, Variants in new type-decl..union(#loc from(R), Name, Formals, Variants) },
    "TypeVariant_variant": {R, Name, _, Fields, _ in new variant(#loc from(R), Name, Fields)},
    "TypeField_field": {R, Name, _, Type in new field(#loc from(R), Name, Type)},

    "TypeApp_list": {R, Type, _ in new type-app..list(#loc from(R), Type)},
    "TypeApp1_maybe": {R, Type, _ in new type-app..maybe(#loc from(R), Type)},
    "TypeApp2_apply": {R, Type, _, Args, _ in new type-app..apply(#loc from(R), Type, Args)},
    "TypeApp3_project": {R, Type, _, Field in new type-app..project(#loc from(R), Type, Field)},
    "TypeApp4_name": {R, Name in new type-app..ref(#loc from(R), Name)},
    "TypeApp4_parens": {R, _, T, _ in T},

    "Grammar_grammar": {R, TypeDecl, _, Name, _, Type, _, Rules, _ in new grammar(Name, Type, Rules, TypeDecl)},
    "Rule_token": {R, _, Rule in new rule..token(#loc from(R), Rule)},
    "Rule_define": {R, Sig, Desc, _, Body in new rule..define(#loc from(R), Sig, #maybe from(nullable: Desc), Body)},
    "Rule_override": {R, Sig, _, Body in new rule..define(#loc from(R), Sig, Body)},
    "Rule_extend": {R, Sig, _, Body in new rule..extend(#loc from(R), Sig, Body)},
    "RuleSig": {R, Name, Formals in new rule-signature(Name, Formals)},
    "RuleBody_body": {R, _, Terms in Terms},
    "TopLevelTerm_action": {R, Terms, _, Action in new rule-body(#loc from(R), Terms, #maybe of(Action))},
    "TopLevelTerm_no_action": {R, Terms in new rule-body(#loc from(R), Terms, maybe..none)},
    "Binder_bound": {R, Name, _, Term in new binder..bound(#loc from(R), Name, Term)},
    "Binder_unbound": {R, Term in new binder..unbound(#loc from(R), Term)},

    "Action_make": {R, Type, _, Args, _ in new expr..meta(#loc from(R))},
    "Action_apply": {R, _, Name, _, Args, _ in new expr..apply(#loc from(R), Name, Args)},
    "ActionProject_project": {R, Type, _, Name in new expr..project(#loc from(R), Type, Name)},
    "ActionPrimary_meta": {R, _ in new expr..meta(#loc from(R))},
    "ActionPrimary_var": {R, Name in new expr..var(#loc from(R), Name)},
    "ActionPrimary_null": {R, _ in new expr..null(#loc from(R))},
    "ActionPrimary_parens": {R, _, Action, _ in Action},
    "ActionList_cons": {R, _, Head, _, _, Tail, _ in new expr..cons(#loc from(R), Head, Tail)},
    "ActionList_list": {R, _, Items, _ in new expr..list(#loc from(R), Items)},

    "Formals_list": {R, _, Items, _ in Items},
    "Formals_empty": {R in []},
    "Params_list": {R, _, Items, _ in Items},
    "Params_empty": {R in []},

    "Alt_alt": {R, Terms in new term..alt(#loc from(R), Terms)},
    "Iter_seq": {R, Terms in new term..seq(#loc from(R), Terms)},
    "Iter_star": {R, Term, _ in new term..star(#loc from(R), Term)},
    "Iter_plus": {R, Term, _ in new term..plus(#loc from(R), Term)},
    "Iter_opt": {R, Term, _ in new term..opt(#loc from(R), Term)},
    "Pred_not": {R, _, Term in new term..not(#loc from(R), Term)},
    "Pred_lookahead": {R, _, Term in new term..lookahead(#loc from(R), Term)},

    "Lex_lex": {R, _, Term in new term..lex(#loc from(R), Term)},
    "Base_apply": {R, Name, Params in new term..apply(#loc from(R), Name, Params)},
    "Base_range": {R, S, _, E in new term..range(#loc from(R), S, E)},
    "Base_terminal": {R, T in new term..terminal(#loc from(R), T)},
    "Base_parens": {R, _, T, _ in new term..parens(#loc from(R), T)},
    "Name": {R in new ref..relative(#loc from(R), [#loc source(R)])},

    "ruleDescr_desc": {R, _, T, _ in T},
    "ruleDescrText": {R in #loc source(R)},
    "name": {R in #loc source(R)},
    "t_terminal": {R in #loc source(R)},
    "t_oneCharTerminal": {R in #loc source(R)},
    "terminalChar": {R in #loc source(R)},
    "comment": {R in #loc source(R)},

    "escapeChar_unicode": {R, _, A, B, C, D in #loc source(R) },
    "escapeChar_ascii": {R, _, A, B in #loc source(R) }
  ]);

  when {
    Result0 at!(0n) => #result ok(Result0 at!(1n));
    otherwise => #result error(new load-error..syntax-error(Result0 at!(1n)));
  }
}