% meow/1

// -- Equality -----------------------------------------------------------------
def array<A> === (X: array<A>) -> bool {
  when {
    self count() =/= X count() => false;
    otherwise => self zip(X, with: {A, B in A === B});
  }
}

// -- Container ----------------------------------------------------------------
def array contains(Value: unknown) -> bool {
  self some({X in X =:= Value});
}

// -- Countable container ------------------------------------------------------
def array count() -> i32 {
  primitive array.count(self);
}

def array is-empty() -> bool {
  self count() === 0n;
}

// -- Sequence -----------------------------------------------------------------
def array first!() -> T {
  self at!(0n);
}

def array rest() -> array<T> {
  self slice(from: 1);
}

// -- Finite sequence ----------------------------------------------------------
def array last!() -> T {
  self at!(self count() - 1);
}

def array without-last() -> array<T> {
  when {
    self count() < 2n => [];
    otherwise => self slice(from: 0n, to: self count() - 1n)
  }
}

// -- Appendable sequence ------------------------------------------------------
def array<T> ++ (That: array<T>) -> array<T> {
  primitive array.concat(self, That);
}

def array<T> append(Value: T) -> array<T> {
  self ++ [Value];
}

def array<T> prepend(Value: T) -> array<T> {
  [Value] ++ self;
}

def #array empty() -> array<T> {
  [];
}

// -- Indexed sequence ---------------------------------------------------------
def array<T> at!(Index: i32) -> T {
  assert (Index >= 0n) and (Index < self count()) :: in-range;
  primitive array.at(self, Index);
}

// -- Growable indexed sequence ------------------------------------------------
def array<T> remove(at Index: i32) -> array<T> {
  primitive array.remove-at(self, Index);
}

def array<T> insert(Value: T, before Index: i32) -> array<T> {
  primitive array.insert-before(self, Index, Value);
}

def array<T> insert(Value: T, after Index: i32) -> array<T> {
  primitive array.insert-after(self, Index, Value);
}

// -- Modifiable indexed sequence ----------------------------------------------
def array<T> put(Value: T, at Index: i32) -> array<T> {
  primitive array.at-put(self, Index, Value);
}

// -- Reversible sequence ------------------------------------------------------
def array<T> reverse() -> array<T> {
  primitive array.reverse(self);
}

// -- Sliceable sequence -------------------------------------------------------
def array slice(from Start: i32, to End: i32) -> array {
  assert Start >= 0n :: positive-start;
  assert End >= Start :: positive-slice;
  primitive array.slice(self, Start, End);
}

def array slice(from Start: i32) -> array {
  primitive array.slice-from(self, Start);
}

def array slice(to End: i32) -> array {
  primitive array.slice-to(self, End);
}

// -- Sortable sequence --------------------------------------------------------
def array sort(by Compare: lambda-2) -> array {
  primitive array.sort-by(self, { A, B in Compare(A, B) as i32 });
}

def array sort() -> array {
  self sort(by: { A, B in A compare-to(B) });
}

// -- Mappable collection ------------------------------------------------------
def array map(Fn: lambda-1) -> array {
  primitive array.map(self, Fn);
}

// -- Chainable collection -----------------------------------------------------
def array flat-map(Fn: lambda-1) -> array {
  primitive array.flat-map(self, Fn);
}

def array flatten-once() -> array {
  self flat-map({ X in X });
}

// -- Filterable collection ----------------------------------------------------
def array keep-if(Fn: lambda-1) -> array {
  primitive array.filter(self, Fn);
}

def array remove-if(Fn: lambda-1) -> array {
  self keep-if({X in not Fn(X)});
}

// -- Foldable collection ------------------------------------------------------
def array fold(from Init: unknown, with Fn: lambda-2) -> unknown {
  primitive array.fold-left(self, Init, Fn);
}

def array fold-right(from Init: unknown, with Fn: lambda-2) -> unknown {
  primitive array.fold-right(self, Init, Fn);
}

def array fold(with Fn: lambda-2) -> unknown {
  assert not self is-empty();
  self rest() fold(from: self first(), with: Fn);
}

def array fold-right(with Fn: lambda-2) -> unknown {
  assert not self is-empty();
  self rest() fold-right(from: self last(), with: Fn);
}

def array all(Fn: lambda-1) -> bool {
  primitive array.every(self, Fn);
}

def array some(Fn: lambda-1) -> bool {
  primitive array.some(self, Fn);
}

def array none(Fn: lambda-1) -> bool {
  not self all(Fn);
}

// -- Zippable collection ------------------------------------------------------
def array zip(That: array, with Combine: lambda-2) -> array {
  assert self count() === That count();
  primitive array.zip-with(self, That, Combine);
}

// -- Modifiable container -----------------------------------------------------
def array add(Value: unknown) -> array {
  self append(Value);
}

def array remove(Value: unknown) -> Array {
  self remove-if({X in X =:= Value});
}

// -- Conversions --------------------------------------------------------------
def array as stream {
  #stream from(self);
}