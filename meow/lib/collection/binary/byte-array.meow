% meow/1

def byte-array count() -> i32 {
  primitive binary.count(self);
} test {
  assert <<>> count() ==> 0n;
  assert <<1, 2, 3>> count() ==> 3n;
}

// -- Constructing -------------------------------------------------------------
def #byte-array allocate(size Size: i32, default Default: i32) -> byte-array {
  primitive binary.allocate(Size, Default);
} test {
  assert #byte-array allocate(size: 4n, default: 1n) ==> <<1, 1, 1, 1>>;
}

def #byte-array allocate(size Size: i32) -> byte-array {
  self allocate(size: Size, default: 0n);
} test {
  assert #byte-array allocate(size: 4n) ==> <<0, 0, 0, 0>>;
}

def #byte-array from(Array: array<i32>) -> byte-array {
  primitive binary.from-array(Array);
} test {
  assert #byte-array from([]) ==> <<>>;
  assert #byte-array from([1n, 2n, 3n]) ==> <<1, 2, 3>>;
}

def #byte-array concat(Arrays: array<byte-array>) -> byte-array {
  primitive binary.concat(Arrays);
} test {
  assert #byte-array concat([<<1>>, <<>>, <<2>>, <<3, 4>>]) ==> <<1, 2, 3, 4>>;
}


// -- Indexing -----------------------------------------------------------------
def byte-array at!(Index: i32) -> i32 {
  assert (Index >= 0n) and (Index < self count()) :: in-bounds;
  primitive binary.at(self, Index);
} test {
  assert <<1>> at!(0n) ==> 1n;
  assert <<1, 2, 3>> at!(1n) ==> 2n;
}

def byte-array at(Index: i32) -> maybe<i32> {
  when {
    Index < 0n => maybe..none;
    Index >= self count() => maybe..none;
    otherwise => #maybe of(self at!(Index));
  }
} test {
  assert <<>> at(0n) ==> maybe..none;
  assert <<1, 2, 3>> at(1n) unwrap() ==> 2n;
  assert <<1, 2, 3>> at(5n) ==> maybe..none;
}

// -- Slicing ------------------------------------------------------------------
def byte-array slice(from Start: i32, length Length: i32) -> byte-slice {
  assert Length >= 0n :: positive-slice;
  assert (Start >= 0n) and ((Start + Length) <= self count()) :: in-bounds;
  new byte-slice(array: self, offset: Start, length: Length);
} test {
  assert <<>> slice(from: 0n, length: 0n) as byte-array ==> <<>>;
  assert <<1, 2, 3>> slice(from: 0n, length: 3n) as byte-array ==> <<1, 2, 3>>;
  assert <<1, 2, 3>> slice(from: 1n, length: 1n) as byte-array ==> <<2>>;
}

def byte-array slice(from Start: i32, to Stop: i32) -> byte-slice {
  self slice(from: Start, length: Stop - Start);
} test {
  assert <<1, 2, 3>> slice(from: 1n, to: 2n) as byte-array ==> <<2>>;
}

def byte-array slice(from Start: i32) -> byte-slice {
  self slice(from: Start, length: self count() - Start);
} test {
  assert <<1, 2, 3>> slice(from: 1n) as byte-array ==> <<2, 3>>;
}

def byte-array slice(length Length: i32) -> byte-slice {
  self slice(from: 0n, length: Length);
} test {
  assert <<1, 2, 3>> slice(length: 1n) as byte-array ==> <<1>>;
}

// -- Equality -----------------------------------------------------------------
def byte-array === (X: byte-array) -> bool {
  primitive binary.eq(self, X);
} test {
  assert <<>> === <<>>;
  assert <<1, 2, 3>> === <<1, 2, 3>>;
  assert not (<<1, 2, 3>> === <<1, 1, 3>>);
  assert not (<<1, 2, 3>> === <<1, 2, 3, 4>>);
}

def byte-array =/= (X: byte-array) -> bool {
  not (self === X);
} test {
  assert not (<<>> =/= <<>>);
  assert not (<<1, 2, 3>> =/= <<1, 2, 3>>);
  assert (<<1, 2, 3>> =/= <<1, 1, 3>>);
  assert (<<1, 2, 3>> =/= <<1, 2, 3, 4>>);
}


// -- Conversions --------------------------------------------------------------
def byte-array as byte-slice = self slice(from: 0);
def byte-array as array = primitive binary.to-array(self);
def byte-array mutable-copy() -> mutable-byte-array = new mutable-byte-array(self);
