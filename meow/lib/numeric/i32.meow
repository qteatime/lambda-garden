% meow/1

// TODO: tests for trapped overflow/underflow

// -- Arithmetic ---------------------------------------------------------------
def i32 + (X: i32) -> i32 {
  primitive i32.add(self, X);
} test {
  assert 0n + 0n ==> 0n;
  assert 1n + 0n ==> 1n;
  assert 0n + 1n ==> 1n;
  assert -3n + 1n ==> -2n;
  assert 5n + 3n ==> 8n;
  assert 20n + 22n ==> 42n;
}

def i32 - (X: i32) -> i32 {
  primitive i32.sub(self, X);
} test {
  assert 0n - 0n ==> 0n;
  assert 1n - 0n ==> 1n;
  assert 0n - 1n ==> -1n;
  assert -3n - 1n ==> -4n;
  assert 5n - 3n ==> 2n;
  assert 20n - 22n ==> -2n;
  assert 22n - 20n ==> 2n;
}

def i32 * (X: i32) -> i32 {
  primitive i32.mul(self, X);
} test {
  assert 0n * 0n ==> 0n;
  assert 1n * 0n ==> 0n;
  assert 0n * 1n ==> 0n;
  assert 1n * 1n ==> 1n;
  assert 20n * 2n ==> 40n;
}

def i32 \ (X: i32) -> i32 {
  assert X =/= 0n :: non-zero-divisor;
  primitive i32.div(self, X);
} test {
  assert 4n \ 2n ==> 2n;
  assert 3n \ 2n ==> 1n;
  assert 1n \ 3n ==> 0n;
  assert 0n \ 1n ==> 0n;
  assert 3n \ -1n ==> -3n;
  // TODO: test trapped divide by zero
}

def i32 ** (X: i32) -> i32 {
  assert X >= 0n :: positive-exponent;
  primitive i32.pow(self, X);
} test {
  assert 1n ** 0n ==> 1n;
  assert 0n ** 0n ==> 1n;
  assert 3n ** 0n ==> 1n;
  assert 1n ** 1n ==> 1n;
  assert -1n ** 1n ==> -1n;
  assert 2n ** 6n ==> 64n;
}

def i32 % (X: i32) -> i32 {
  assert X =/= 0n :: non-zero-divisor;
  primitive i32.mod(self, X);
} test {
  assert 4n % 2n ==> 0n;
  assert 3n % 2n ==> 1n;
  assert 1n % 3n ==> 1n;
  assert 0n % 1n ==> 0n;
  assert 3n % -1n ==> 0n;
  assert (123456789n % 12n) ==> 9n;
}

// -- Relational ---------------------------------------------------------------
def i32 === (X: i32) -> bool {
  primitive i32.eq(self, X);
} test {
  assert 0n === 0n;
  assert 1n === 1n;
  assert not (1n === -1n);
  assert not (1n === 2n);
}

def i32 =/= (X: i32) -> bool {
  primitive i32.neq(self, X);
} test {
  assert 1n =/= -1n;
  assert 1n =/= 2n;
  assert not (0n =/= 0n);
  assert not (1n =/= 1n);
}

def i32 < (X: i32) -> bool {
  primitive i32.lt(self, X);
} test {
  assert 0n < 1n;
  assert -1n < 0n;
  assert not (0n < 0n);
  assert not (1n < 0n);
}

def i32 <= (X: i32) -> bool {
  primitive i32.lte(self, X);
} test {
  assert 0n <= 1n;
  assert -1n <= 0n;
  assert 0n <= 0n;
  assert not (1n <= 0n);
}

def i32 > (X: i32) -> bool {
  primitive i32.gt(self, X);
} test {
  assert 1n > 0n;
  assert 0n > -1n;
  assert not (0n > 0n);
  assert not (0n > 1n);
}

def i32 >= (X: i32) -> bool {
  primitive i32.gte(self, X);
} test {
  assert 1n >= 0n;
  assert 0n >= -1n;
  assert 0n >= 0n;
  assert not (0n >= 1n);
}

def i32 compare-to(X: i32) -> ordering {
  when {
    self < X => ordering..less-than;
    self === X => ordering..equal;
    self > X => ordering..greater-than;
  }
}

// -- Bitwise ------------------------------------------------------------------
def i32 << (X: i32) -> i32 {
  primitive i32.bshl(self, X);
} test {
  assert 1n << 2n ==> 4n;
}

def i32 >> (X: i32) -> i32 {
  primitive i32.bashr(self, X);
} test {
  assert 8n >> 2n ==> 2n;
}

def i32 >>> (X: i32) -> i32 {
  primitive i32.blshr(self, X);
} test {
  assert 8n >>> 1n ==> 4n;
}

def i32 & (X: i32) -> i32 {
  primitive i32.band(self, X);
} test {
  assert 1n & 2n ==> 0n;
}

def i32 | (X: i32) -> i32 {
  primitive i32.bor(self, X);
} test {
  assert 1n | 2n ==> 3n;
}

def i32 ^ (X: i32) -> i32 {
  primitive i32.bxor(self, X);
} test {
  assert 1n ^ 2n ==> 3n;
}

def ~i32 -> i32 {
  primitive i32.bnot(self);
} test {
  assert ~(1n) ==> -2n;
}

// -- Other transformations ----------------------------------------------------
def -i32 -> i32 {
  primitive i32.negate(self);
} test {
  assert -(0n) ==> 0n;
  assert -(1n) ==> -1n;
  assert -(-1n) ==> 1n;
}

def i32 absolute() -> i32 {
  when {
    self < 0n => -(self);
    otherwise => self;
  }
} test {
  assert 0n absolute() ==> 0n;
  assert 1n absolute() ==> 1n;
  assert -1n absolute() ==> 1n;
}

// -- Conversions --------------------------------------------------------------
def i32 as text {
  primitive i32.to-text(self);
} test {
  assert 123n as text ==> "123";
}

def i32 as integer {
  primitive i32.to-integer(self);
} test {
  assert 4n as integer ==> 4;
  assert -4n as integer ==> -4;
}

def i32 as f64 {
  primitive i32.to-f64(self);
}

def i32 as bool {
  primitive i32.to-bool(self);
} test {
  assert 1n as bool ==> true;
  assert -1n as bool ==> true;
  assert 0n as bool ==> false;
}
