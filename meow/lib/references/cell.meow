% meow/1

def #cell of(Value: T) -> cell<T> {
  primitive cell.new(Value);
}

def #cell empty() -> cell<T> {
  #cell of(nothing);
}

def cell<T> read() -> T {
  primitive cell.deref(self);
}

def cell<T> <- (Value: T) -> T {
  primitive cell.exchange(self, Value);
}

def cell<T> set(Value: T, if-contains Old: T) -> bool {
  let Got = self <- Value;
  when {
    Got =:= Old => true;
    otherwise => {
      self <- Got;
      false;
    }
  }
} test {
  let A = #cell of(1n);
  assert A set(2n, if-contains: 1n) ==> true;
  assert A read() ==> 2n;
  assert A set(3n, if-contains: 1n) ==> false;
  assert A read() ==> 2n;
}

test "basic cells" {
  let A = #cell of(1n);
  assert A read() ==> 1n;
  let B = #cell empty();
  assert B read() ==> nothing;
  assert (A <- 2n) ==> 1n;
  assert A read() ==> 2n;
  assert (B <- 1n) ==> nothing;
  assert B read() ==> 1n;
}

