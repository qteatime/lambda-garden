% meow/1

def byte-array count() -> int {
  primitive binary.count(self);
} test {
  assert <<>> count() ==> 0;
  assert <<1, 2, 3>> count() ==> 3;
}

// -- Constructing -------------------------------------------------------------
def #byte-array allocate(size Size: int, default Default: int) -> byte-array {
  primitive binary.allocate(Size, Default);
} test {
  assert #byte-array allocate(size: 4, default: 1) ==> <<1, 1, 1, 1>>;
}

def #byte-array allocate(size Size: int) -> byte-array {
  self allocate(size: Size, default: 0);
} test {
  assert #byte-array allocate(size: 4) ==> <<0, 0, 0, 0>>;
}

def #byte-array from(Array: array<int>) -> byte-array {
  primitive binary.from-array(Array);
} test {
  assert #byte-array from([]) ==> <<>>;
  assert #byte-array from([1, 2, 3]) ==> <<1, 2, 3>>;
}

def #byte-array concat(Arrays: array<byte-array>) -> byte-array {
  primitive binary.concat(Arrays);
} test {
  assert #byte-array concat([<<1>>, <<>>, <<2>>, <<3, 4>>]) ==> <<1, 2, 3, 4>>;
}


// -- Indexing -----------------------------------------------------------------
def byte-array at!(Index: int) -> int {
  assert (Index >= 0) and (Index < self count()) :: in-bounds;
  primitive binary.at(self, Index);
} test {
  assert <<1>> at!(0) ==> 1;
  assert <<1, 2, 3>> at!(1) ==> 2;
}

def byte-array at(Index: int) -> maybe<int> {
  when {
    Index < 0 => maybe..none;
    Index >= self count() => maybe..none;
    otherwise => #maybe some(self at!(Index));
  }
} test {
  assert <<>> at(0) ==> maybe..none;
  assert <<1, 2, 3>> at(1) unwrap() ==> 2;
  assert <<1, 2, 3>> at(5) ==> maybe..none;
}

// -- Slicing ------------------------------------------------------------------
def byte-array slice(from Start: int, length Length: int) -> byte-slice {
  assert Length >= 0 :: positive-slice;
  assert (Start >= 0) and ((Start + Length) <= self count()) :: in-bounds;
  new byte-slice(array: self, offset: Start, length: Length);
} test {
  assert <<>> slice(from: 0, length: 0) as byte-array ==> <<>>;
  assert <<1, 2, 3>> slice(from: 0, length: 3) as byte-array ==> <<1, 2, 3>>;
  assert <<1, 2, 3>> slice(from: 1, length: 1) as byte-array ==> <<2>>;
}

def byte-array slice(from Start: int, to Stop: int) -> byte-slice {
  self slice(from: Start, length: Stop - Start);
} test {
  assert <<1, 2, 3>> slice(from: 1, to: 2) as byte-array ==> <<2>>;
}

def byte-array slice(from Start: int) -> byte-slice {
  self slice(from: Start, length: self count() - Start);
} test {
  assert <<1, 2, 3>> slice(from: 1) as byte-array ==> <<2, 3>>;
}

def byte-array slice(length Length: int) -> byte-slice {
  self slice(from: 0, length: Length);
} test {
  assert <<1, 2, 3>> slice(length: 1) as byte-array ==> <<1>>;
}

// -- Equality -----------------------------------------------------------------
def byte-array === (X: byte-array) -> bool {
  primitive binary.eq(self, X);
} test {
  assert <<>> === <<>>;
  assert <<1, 2, 3>> === <<1, 2, 3>>;
  assert not (<<1, 2, 3>> === <<1, 1, 3>>);
  assert not (<<1, 2, 3>> === <<1, 2, 3, 4>>);
}

def byte-array =/= (X: byte-array) -> bool {
  not (self === X);
} test {
  assert not (<<>> =/= <<>>);
  assert not (<<1, 2, 3>> =/= <<1, 2, 3>>);
  assert (<<1, 2, 3>> =/= <<1, 1, 3>>);
  assert (<<1, 2, 3>> =/= <<1, 2, 3, 4>>);
}


// -- Conversions --------------------------------------------------------------
def byte-array as byte-slice = self slice(from: 0);
def byte-array as array = primitive binary.to-array(self);
def byte-array mutable-copy() -> mutable-byte-array = new mutable-byte-array(self);
