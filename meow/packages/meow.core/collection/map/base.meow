% meow/1

def map<K, V> keys() =
  primitive map.keys(self);

def map<K, V> values() =
  primitive map.values(self);

def map<K, V> entries() {
  primitive map.entries(self);
} test {
  assert [1: true, 2: true, 3: true] entries() ==> [
    #(key: 1, value: true),
    #(key: 2, value: true),
    #(key: 3, value: true),
  ];
}


def map<K, V> count() {
  primitive map.count(self);
} test {
  assert [:] count() ==> 0;
  assert [1: true, 2: true, 3: true] count() ==> 3;
}


def map<K, V> at(Key: K) -> maybe<V> {
  when {
    self contains(key: Key) => #maybe some(primitive map.get(self, Key));
    otherwise => maybe..none;
  }
}

def map<K, V> at!(Key: K) -> maybe<V> {
  self at(Key) unwrap();
}

def map<K, V> contains(key Key: K) -> bool {
  primitive map.has(self, Key);
}


def map<K, V> === (X: map<K, V>) {
  when {
    self count() =/= X count() => false;
    otherwise =>
      self entries() all({ Entry in
        X at(Entry.key) map(_ === Entry.value) unwrap(default: false);
      });
  }
} test {
  assert [:] === [:];
  assert ["a": 1, "b": 2] === ["b": 2, "a": 1];
  assert not (["a": 1] === ["a": 1, "b": 2]);
  assert not (["a": 1, "b": 2] === ["a": 1]);
  assert not (["a": 1, "b": 2] === ["a": 1, "b": 1]);
}