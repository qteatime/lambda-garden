% meow/1

// -- Constructors -------------------------------------------------------------
def #stream empty() -> stream<A> {
  stream..empty;
}

def #stream from(Items: array<A>) -> stream<A> {
  Items fold-right(from: #stream empty(), with: { X, Tail in
    new stream..cons(head: X, tail: lazy Tail)
  });
} test {
  assert (#stream from([]) as array) ==> [];
  assert (#stream from([1, 2, 3]) as array) ==> [1, 2, 3];
}

def #stream iterate(from Init: A, with Fn: (A) -> A) -> stream<A> {
    new stream..cons(head: Init, tail: lazy #stream iterate(from: Fn(Init), with: Fn));
} test {
  let Naturals = #stream iterate(from: 0, with: {A in A + 1});
  assert (Naturals take(5) as array) ==> [0, 1, 2, 3, 4];
}

// -- Sequence -----------------------------------------------------------------
def stream..cons<A> first!() -> A {
  self.head;
}

def stream..cons<A> first() -> maybe<A> = #maybe some(self.head);
def stream..empty<A> first() -> maybe<A> = maybe..none;

def stream..empty<A> rest() -> stream<A> { self }
def stream..cons<A> rest() -> stream<A> { force self.tail }

// -- Transformations ----------------------------------------------------------
def stream..empty take(Count: int) -> stream<A> { self }
def stream..cons<A> take(Count: int) -> stream<A> {
  assert Count >= 0;
  when {
    Count === 0 => #stream empty();
    otherwise => new stream..cons(head: self first!(), tail: lazy self rest() take(Count - 1));
  }
} test {
  assert (#stream from([]) take(2) as array) ==> [];
  assert #stream from([1, 2, 3]) take(2) as array ==> [1, 2];
  assert #stream from([1, 2, 3]) take(10) as array ==> [1, 2, 3];
  assert #stream from([1, 2, 3]) take(0) as array ==> [];
}

def stream..empty drop(Count: int) -> stream<A> { self }
def stream..cons<A> drop(Count: int) -> stream<A> {
  assert Count >= 0;
  when {
    Count === 0 => self;
    otherwise => self rest() drop(Count - 1);
  }
} test {
  assert #stream from([]) drop(2) as  array ==> [];
  assert #stream from([1, 2, 3]) drop(2) as array ==> [3];
  assert #stream from([1, 2, 3]) drop(10) as array ==> [];
  assert #stream from([1, 2, 3]) drop(0) as array ==> [1, 2, 3];
}

def stream..empty take-while(Count: int) -> stream<A> { self }
def stream..cons<A> take-while(Predicate: (A) -> bool) -> stream<A> {
  when {
    Predicate(self first!()) => new stream..cons(head: self first!(), tail: lazy self rest() take-while(Predicate));
    otherwise => #stream empty();
  }
} test {
  let Naturals = #stream iterate(from: 0, with: { A in A + 1 });
  assert Naturals take-while({X in X < 5}) as array ==> [0, 1, 2, 3, 4];
}

def stream..empty drop-while(Count: int) -> stream<A> { self }
def stream..cons<A> drop-while(Predicate: (A) -> bool) -> stream<A> {
  when {
    not Predicate(self first!()) => self;
    otherwise => self rest() drop-while(Predicate);
  }
} test {
  let Naturals = #stream iterate(from: 0, with: { A in A + 1 });
  assert Naturals drop-while({X in X < 5}) take(5) as array ==> [5, 6, 7, 8, 9];
}

def stream..empty<A> map(Fn: (A) -> B) -> stream<B> {
  self;
}
def stream..cons<A> map(Fn: (A) -> B) -> stream<B> {
  new stream..cons(head: Fn(self first!()), tail: lazy self rest() map(Fn));
}

def stream..empty<A> keep-if(Fn: (A) -> bool) -> stream<A> {
  self;
}
def stream..cons<A> keep-if(Fn: (A) -> bool) -> stream<A> {
  when {
    Fn(self first!()) => new stream..cons(head: self first!(), tail: lazy self rest() keep-if(Fn));
    otherwise => self rest() keep-if(Fn);
  }
}

def stream<A> remove-if(Fn: (A) -> bool) -> stream<A> {
  self keep-if({X in not Fn(X)});
}

// -- Folds --------------------------------------------------------------------
def stream..empty fold(from Init: B, with Fn: (B, A) -> B) {
  Init;
}
def stream..cons<A> fold(from Init: B, with Fn: (B, A) -> B) -> B {
  Fn(Init, (force self.tail) fold(from: self.head, with: Fn));
}

def stream<A> sum(of Type: #f64) -> f64 {
  self fold(from: 0.0f, with: {A, B in A + B});
}

def stream<A> sum(of Type: #int) -> int {
  self fold(from: 0.0f, with: {A, B in A + B});
}

def stream<A> sum(of Type: #i64) -> i64 {
  self fold(from: 0, with: {A, B in A + B});
}

// -- Conversions --------------------------------------------------------------
def stream..empty<A> as array {
  [];
}
def stream..cons<A> as array {
  [self.head, ...(force self.tail) as array];
}